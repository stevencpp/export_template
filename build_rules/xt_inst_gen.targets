<?xml version="1.0" encoding="utf-8"?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Xt_ClangPath       Condition="'$(Xt_ClangPath)'      ==''" >c:\Program Files\LLVM\bin</Xt_ClangPath>
    <Xt_TargetsPath     Condition="'$(Xt_TargetsPath)'    ==''" >$(SolutionDir)build_rules\</Xt_TargetsPath>
    <Xt_InstSuffix      Condition="'$(Xt_InstSuffix)'     ==''" >.xti</Xt_InstSuffix>
    <Xt_InstFilePath    Condition="'$(Xt_InstFilePath)'   ==''" >$(SolutionDir)intermediate\src\$(ProjectName)\</Xt_InstFilePath>
    <Xt_InstGen_Path    Condition="'$(Xt_InstGen_Path)'   ==''" >xt_inst_gen.exe</Xt_InstGen_Path>
    <Xt_IntDir_FullPath>$(MSBuildProjectDirectory)\$(IntDir)</Xt_IntDir_FullPath>
    <Xt_IntDir_FullPath Condition="$([System.IO.Path]::IsPathRooted('$(IntDir)'))">$(IntDir)</Xt_IntDir_FullPath>
    <Xt_HeaderCachePath Condition="'$(Xt_HeaderCachePath)'==''" >$(Xt_IntDir_FullPath)xt_header_cache.txt</Xt_HeaderCachePath>
    <Xt_ProjectListFile Condition="'$(Xt_ProjectListFile)'==''" >$(Xt_IntDir_FullPath)xt_project_list.txt</Xt_ProjectListFile>
    <Xt_BuildLogPath    Condition="'$(Xt_BuildLogPath)'   ==''" >$(Xt_IntDir_FullPath)$(MSBuildProjectName).log</Xt_BuildLogPath>
  </PropertyGroup>
  
  <ItemDefinitionGroup>
    <ClCompile>
      <AdditionalIncludeDirectories>$(Xt_InstFilePath);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <!-- note: the following is only necessary if the CUDA.targets is loaded after this .targets file !-->
    <CudaCompile>
      <Include>$(Xt_InstFilePath);%(Include)</Include>
    </CudaCompile>
  </ItemDefinitionGroup>
  
<!-- !-->
  <ItemGroup>
    <Xt_CurrentProject Include="$(ProjectPath)"> <Project>$(ProjectGuid)</Project> </Xt_CurrentProject>
  </ItemGroup>

  <PropertyGroup>
    <!-- the tool needs libclang.dll and clang++.exe to be in PATH !-->
    <Xt_Command>set PATH=%PATH%;$(Xt_ClangPath); &amp;&amp; "$(Xt_InstGen_Path)"</Xt_Command>
    <!-- the XT_Inst_Gen target uses the following to get the ClCompile settings !-->
    <Xt_CompileName>{$([System.Guid]::NewGuid())}</Xt_CompileName>
  </PropertyGroup>
  
  <Target Name="XT_Header_PreFilter" BeforeTargets="XT_Header_Filter">
    <ItemGroup>
      <!-- We can't just get all header files in the project directory because
           e.g CMake may generate the project file at a different location !-->
      <Xt_AllHeaders Include="@(ClInclude)" />
      <!-- In order to support having both the interface and implementation in a single file,
           we should also check if compiled source files with a .h/.cuh extension use [[export_template]] !-->
      <Xt_AllHeaders Include="@(ClCompile);@(CudaCompile)" Condition="$([System.String]::new('%(Extension)').EndsWith('h'))" />
    </ItemGroup>
    <Message Text="all headers: @(Xt_AllHeaders)" Importance="Low"/>
  </Target>
  
  <!-- When any header changes, grep it for [[export_template]] and cache the filtered header list !-->
  <Target Name="XT_Header_Filter" BeforeTargets="Xt_Headers_Read" Inputs="@(Xt_AllHeaders)" Outputs="$(Xt_HeaderCachePath)">
    <Message Text="generating header cache: $(Xt_HeaderCachePath)" Importance="High"/>
    <PropertyGroup>
      <Xt_Command_Filt>$(Xt_Command) filt "@(Xt_AllHeaders)" "$(Xt_HeaderCachePath)"</Xt_Command_Filt>
    </PropertyGroup>
    <Message Text="xt_inst_gen filt: $(Xt_Command_Filt)" Importance="High"/>
    <Exec Command="$(Xt_Command_Filt)" />
  </Target>
  
  <Target Name="Xt_Headers_Read" BeforeTargets="XT_Inst_Gen">
    <!-- the XT_Header_Filter doesn't create a cache file if there are no headers in the project,
	     but the Xt_Build_Instances assumes that a missing cache file is an error,
		 so create it if it doesn't already exist !-->
    <WriteLinesToFile File="$(Xt_HeaderCachePath)" Overwrite="false" />
    <ReadLinesFromFile File="$(Xt_HeaderCachePath)"> <Output TaskParameter="Lines" ItemName="Xt_Headers"/> </ReadLinesFromFile>
    <Message Text="read headers: @(Xt_Headers)" Importance="High"/>
  </Target>

  <!-- In order for a change to the .xti file to trigger building the .cu file,
       the xti file must be added to the .cu file's .deps file, generated by the AddCudaCompileDeps target. !-->
  <Target Name="XT_Inst_Gen" BeforeTargets="ClCompile;AddCudaCompileDeps" Inputs="@(Xt_Headers)" Outputs="@(Xt_Headers->'$(Xt_InstFilePath)%(Filename)$(Xt_InstSuffix)')">
    <!--
      Add temporary ClCompile/Link items in order to read default metadata that's defined in
      ItemDefinitionGroup, then remove the items.
    -->
    <ItemGroup>
      <ClCompile Include="$(Xt_CompileName)" />
      <Xt_CompDef Include="@(ClCompile->WithMetadataValue('Identity', '$(Xt_CompileName)'))" />
      <ClCompile Remove="$(Xt_CompileName)" />
    </ItemGroup>
    
    <PropertyGroup>
      <Xt_PreprocessorDefinitions>%(Xt_CompDef.PreprocessorDefinitions)</Xt_PreprocessorDefinitions>
      <Xt_AdditionalIncludeDirectories>%(Xt_CompDef.AdditionalIncludeDirectories)</Xt_AdditionalIncludeDirectories>
    </PropertyGroup>
    
    <ItemGroup>
      <Xt_Comp_Set Include="@(Xt_Headers)">
        <Command>$(Xt_Command) comp "%(FullPath)" "$(Xt_InstFilePath)%(Filename)$(Xt_InstSuffix)" "$(Xt_PreprocessorDefinitions)" "$(Xt_AdditionalIncludeDirectories)" "$(ProjectGuid)"</Command>
      </Xt_Comp_Set>
    </ItemGroup>
    
    <Message Text="@(Xt_Comp_Set->'xt_inst_gen comp: %(Command)','%0a')" Importance="High"/>
    <Exec Command="%(Xt_Comp_Set.Command)" />
  </Target>
  
<!-- Assume that rebuilding doesn't change the set of template instantiations
     so we don't need to clean and generate the .xti files again !-->
<!--
  <PropertyGroup>
    <CleanDependsOn> XT_BeforeClean; $(CleanDependsOn); </CleanDependsOn>
  </PropertyGroup>
  <Target Name="XT_BeforeClean">
    <ItemGroup>
      <Xt_InstFiles Include="@(Xt_AllHeaders->'$(Xt_InstFilePath)%(Filename)$(Xt_InstSuffix)')" />
    </ItemGroup>
    <Message Text="XT_BeforeClean target executed"/>
    <Delete Files="@(Xt_InstFiles)"/>
    <Delete Files="$(Xt_HeaderCachePath);$(Xt_ProjectListFile)"/>
  </Target>
!-->
  
  <UsingTask TaskName="Xt_Build_Instances" TaskFactory="CodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.v12.0.dll" >
    <ParameterGroup>
      <CurrentProject ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
      <LinkToolCommand ParameterType="System.String" Required="true" />
      <ProjectListFile ParameterType="System.String" Required="true" />
      <SolutionFilePath ParameterType="System.String" Required="true" />
    </ParameterGroup>
    <Task>
      <!-- for the CL and Link tasks !-->
      <Reference Include="$(VCTargetsPath)Microsoft.Build.CppTasks.Common.dll"/>
      <!-- for the MSBuild task !-->
      <Reference Include="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll"/>
      <!-- for ProjectCollections / walking the project tree !-->
      <Reference Include="System.Xml" />
      <Reference Include="Microsoft.Build" />
    
      <Code Type="Class" Language="cs" Source="$(Xt_TargetsPath)Xt_Build_Instances.cs" />
    </Task>
  </UsingTask>
  
  <!-- run this if the build fails, but only if BuildCompile succeeded, i.e if the link failed !-->
  <Target Name="Xt_RunOnError" DependsOnTargets="BuildCompile">
    <PropertyGroup>
      <!-- the command does not include the last parameter, the list of referenced xti files,
           that will be added by the Xt_Build_Instances task !-->
      <Xt_Command_Link>$(Xt_Command) link "$(ProjectName)" "$(Xt_BuildLogPath)" "$(Xt_ProjectListFile)"</Xt_Command_Link>
    </PropertyGroup>
  
    <Message Text="there were link errors - generating template instantiations if necessary" Importance="High"/>
    <Xt_Build_Instances ProjectListFile="$(Xt_ProjectListFile)" CurrentProject="@(Xt_CurrentProject)" SolutionFilePath="$(SolutionPath)"
      LinkToolCommand="$(Xt_Command_Link)" />
    <Message Text="build finished" Importance="High" />
  </Target>

  <!-- todo: what if there are two build customizations used by the same project that both override Build ? !-->
  <Target Name="Build"
    Condition="'$(_InvalidConfigurationWarning)' != 'true'"
    DependsOnTargets="$(BuildDependsOn)"
    Returns="$(TargetPath)">
    <OnError ExecuteTargets="Xt_RunOnError" Condition="'$(Xt_Iteration)' == ''" />
  </Target>
  
  <!-- this should make sure there is a consistent message in the log before every link 
       so that even if linking is done multiple times, the link too can still
       find the unresolved symbols from the last link !-->
  <Target Name="Xt_PreLink" BeforeTargets="Link" DependsOnTargets="BuildCompile" >
    <Message Text="linking project $(ProjectName)" Importance="High"/>
  </Target>

</Project>
